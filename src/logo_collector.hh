#pragma once

#include <memory>
#include <sstream>
#include <tuple>
#include <unordered_set>

#include <cppcodec/base64_rfc4648.hpp>
#include <rapidjson/document.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/writer.h>
#include <tsduck/tsduck.h>

#include "base.hh"
#include "jsonl_source.hh"
#include "logging.hh"
#include "packet_source.hh"

namespace {

struct LogoData {
  uint8_t type = 0;
  uint16_t id = 0;
  uint16_t version = 0;
  uint16_t size = 0;
  const uint8_t* data = nullptr;

  LogoData() = default;

  LogoData(const uint8_t* data, size_t size) {
    MIRAKC_ARIB_ASSERT(size >= 7);
    this->type = ts::GetUInt8(data);
    this->id = ts::GetUInt16(data + 1) & 0x01FF;
    this->version = ts::GetUInt16(data + 3) & 0x0FFF;
    this->size = ts::GetUInt16(data + 5);
    this->data = data + 7;
    MIRAKC_ARIB_ASSERT(size == this->size + 7);
  }
};

struct CdtSection {
  uint16_t pid;
  uint16_t tid;
  uint16_t nid;
  uint16_t ddid;
  uint8_t data_type;
  uint8_t section_number;
  uint8_t last_section_number;
  uint8_t version;
  const uint8_t* descs_data;
  size_t descs_size;
  LogoData logo;

  static constexpr size_t CDT_PAYLOAD_FIXED_SIZE = 5;

  CdtSection(const ts::Section& section) {
    const auto* data = section.payload();
    auto size = section.payloadSize();

    pid = section.sourcePID();
    tid = section.tableId();
    nid = ts::GetUInt16(data);
    ddid = section.tableIdExtension();
    data_type = ts::GetUInt8(data + 2);
    section_number = section.sectionNumber();
    last_section_number = section.lastSectionNumber();
    version = section.version();
    descs_data = data + CDT_PAYLOAD_FIXED_SIZE;
    descs_size = ts::GetUInt16(data + 3) & 0x0FFF;

    MIRAKC_ARIB_ASSERT(size >= CDT_PAYLOAD_FIXED_SIZE + descs_size);

    logo = LogoData(
        descs_data + descs_size, size - CDT_PAYLOAD_FIXED_SIZE - descs_size);
  }

  std::string id() const {
    std::stringstream ss;
    ss << nid << " "
       << ddid << " "
       << logo.type << " "
       << logo.id << " "
       << logo.version;
    return ss.str();
  }
};

struct LogoCollector final : public PacketSink,
                             public JsonlSource,
                             public ts::SectionHandlerInterface {
 public:
  explicit LogoCollector()
      : demux_(context_) {
    demux_.setSectionHandler(this);
    demux_.addPID(ts::PID_CDT);
  }

  ~LogoCollector() override {}

  bool Start() override {
    start_time_ = ts::Time::CurrentUTC();
    return true;
  }

  bool End() override {
    auto elapse = ts::Time::CurrentUTC() - start_time_;
    auto min = elapse / ts::MilliSecPerMin;
    auto sec = (elapse - min * ts::MilliSecPerMin) / ts::MilliSecPerSec;
    auto ms = elapse % ts::MilliSecPerSec;
    MIRAKC_ARIB_INFO("Collected {} logos, {}:{:02d}.{:03d} elapsed",
                     num_logos_, min, sec, ms);
    return IsCompleted();
  }

  bool HandlePacket(const ts::TSPacket& packet) override {
    demux_.feedPacket(packet);
    if (IsCompleted()) {
      MIRAKC_ARIB_INFO("Completed");
      return false;
    }
    return true;
  }

 private:
  void handleSection(ts::SectionDemux&, const ts::Section& section) override {
    if (!section.isValid()) {
      MIRAKC_ARIB_WARN("Broken section");
      return;
    }

    const auto tid = section.tableId();
    if (tid != ts::TID_CDT) {
      MIRAKC_ARIB_WARN("Not CDT section");
      return;
    }

    CdtSection cdt(section);
    if (CheckCollected(cdt)) {
      return;
    }

    if (cdt.data_type != 1) {
      return;
    }

    num_logos_++;

    MIRAKC_ARIB_INFO(
        "CDT: sec({:02X}/{:02X}) ver({:02d}) "
        "nid({:04X}) ddid({:04X}) data-type({:02X}) "
        "logo-type({}) logo-id({}) logo-version({}) logo-size({})",
        cdt.section_number, cdt.last_section_number, cdt.version,
        cdt.nid, cdt.ddid, cdt.data_type,
        cdt.logo.type, cdt.logo.id, cdt.logo.version, cdt.logo.size);

    WriteCdtSection(cdt);
  }

  void WriteCdtSection(const CdtSection& cdt) {
    auto json = MakeJsonValue(cdt);
    FeedDocument(json);
  }

  rapidjson::Document MakeJsonValue(const CdtSection& cdt) {
    rapidjson::Document json(rapidjson::kObjectType);
    auto& allocator = json.GetAllocator();

    std::string data = MakeBase64Png(cdt.logo.data, cdt.logo.size);

    rapidjson::Value logo(rapidjson::kObjectType);
    logo.AddMember("type", cdt.logo.type, allocator);
    logo.AddMember("id", cdt.logo.id, allocator);
    logo.AddMember("version", cdt.logo.version, allocator);
    logo.AddMember("data", data, allocator);

    json.AddMember("nid", cdt.nid, allocator);
    json.AddMember("ddid", cdt.ddid, allocator);
    json.AddMember("logo", logo, allocator);

    return json;
  }

  static inline std::string MakeBase64Png(const uint8_t* data, size_t size) {
    auto [png, png_size] = InsertPngChunks(data, size);
    return cppcodec::base64_rfc4648::encode(png.get(), png_size);
  }

  static inline std::tuple<std::unique_ptr<uint8_t[]>, size_t> InsertPngChunks(
      const uint8_t* data, size_t size) {
    // PLTE and tRNS chunks extracted from a logo data downloaded from
    // Mirakurun.
    //
    //   curl -fsSL http://mirakurun:40772/services/{id}/logo \
    //     | tail -c +34 | head -c 540 | xxd -i
    //
    static const uint8_t kChunks[540] = {
      0x00, 0x00, 0x01, 0x83, 0x50, 0x4c, 0x54, 0x45, 0x00, 0x00, 0x00, 0xff,
      0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff,
      0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xaa,
      0x00, 0x00, 0x00, 0xaa, 0x00, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0xaa, 0xaa,
      0x00, 0xaa, 0x00, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0x00, 0x55, 0x00,
      0x55, 0x00, 0x00, 0x55, 0x55, 0x00, 0x55, 0xaa, 0x00, 0x55, 0xff, 0x00,
      0xaa, 0x55, 0x00, 0xaa, 0xff, 0x00, 0xff, 0x55, 0x00, 0xff, 0xaa, 0x55,
      0x00, 0x00, 0x55, 0x00, 0x55, 0x55, 0x00, 0xaa, 0x55, 0x00, 0xff, 0x55,
      0x55, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0x55, 0x55, 0xff, 0x55,
      0xaa, 0x00, 0x55, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0xaa, 0xff, 0x55,
      0xff, 0x00, 0x55, 0xff, 0x55, 0x55, 0xff, 0xaa, 0x55, 0xff, 0xff, 0xaa,
      0x00, 0x55, 0xaa, 0x00, 0xff, 0xaa, 0x55, 0x00, 0xaa, 0x55, 0x55, 0xaa,
      0x55, 0xaa, 0xaa, 0x55, 0xff, 0xaa, 0xaa, 0x55, 0xaa, 0xaa, 0xff, 0xaa,
      0xff, 0x00, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0xaa, 0xaa, 0xff, 0xff, 0xff,
      0x00, 0x55, 0xff, 0x00, 0xff, 0xff, 0x55, 0x00, 0xff, 0x55, 0x55, 0xff,
      0x55, 0xaa, 0xff, 0x55, 0xff, 0xff, 0xaa, 0x00, 0xff, 0xaa, 0x55, 0xff,
      0xaa, 0xaa, 0xff, 0xaa, 0xff, 0xff, 0xff, 0x55, 0xff, 0xff, 0xff, 0x00,
      0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00,
      0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaa,
      0x00, 0x00, 0x00, 0xaa, 0x00, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0xaa, 0xaa,
      0x00, 0xaa, 0x00, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0x00, 0x55, 0x00,
      0x55, 0x00, 0x00, 0x55, 0x55, 0x00, 0x55, 0xaa, 0x00, 0x55, 0xff, 0x00,
      0xaa, 0x55, 0x00, 0xaa, 0xff, 0x00, 0xff, 0x55, 0x00, 0xff, 0xaa, 0x55,
      0x00, 0x00, 0x55, 0x00, 0x55, 0x55, 0x00, 0xaa, 0x55, 0x00, 0xff, 0x55,
      0x55, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa, 0x55, 0x55, 0xff, 0x55,
      0xaa, 0x00, 0x55, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0xaa, 0xff, 0x55,
      0xff, 0x00, 0x55, 0xff, 0x55, 0x55, 0xff, 0xaa, 0x55, 0xff, 0xff, 0xaa,
      0x00, 0x55, 0xaa, 0x00, 0xff, 0xaa, 0x55, 0x00, 0xaa, 0x55, 0x55, 0xaa,
      0x55, 0xaa, 0xaa, 0x55, 0xff, 0xaa, 0xaa, 0x55, 0xaa, 0xaa, 0xff, 0xaa,
      0xff, 0x00, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0xaa, 0xaa, 0xff, 0xff, 0xff,
      0x00, 0x55, 0xff, 0x00, 0xff, 0xff, 0x55, 0x00, 0xff, 0x55, 0x55, 0xff,
      0x55, 0xaa, 0xff, 0x55, 0xff, 0xff, 0xaa, 0x00, 0xff, 0xaa, 0x55, 0xff,
      0xaa, 0xaa, 0xff, 0xaa, 0xff, 0xff, 0xff, 0x55, 0xff, 0xff, 0xff, 0x06,
      0xdd, 0x27, 0x7b, 0x00, 0x00, 0x00, 0x81, 0x74, 0x52, 0x4e, 0x53, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
      0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
      0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
      0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
      0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
      0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x7b, 0x70, 0xf7, 0x6f
    };

    constexpr size_t kIdatOffset = 33;

    MIRAKC_ARIB_ASSERT(size > kIdatOffset);

    auto png = std::make_unique<uint8_t[]>(size + sizeof(kChunks));
    auto* p = png.get();

    std::memcpy(p, data, kIdatOffset);
    p += kIdatOffset;

    std::memcpy(p, kChunks, sizeof(kChunks));
    p += sizeof(kChunks);

    std::memcpy(p, data + kIdatOffset, size - kIdatOffset);

    return std::make_tuple(std::move(png), size + sizeof(kChunks));
  }

  inline bool CheckCollected(const CdtSection& cdt) {
#if 0  // TODO: disabled
    auto id = cdt.id();
    if (collected_.find(id) != collected_.end()) {
      return true;
    }

    collected_.insert(id);
#endif
    return false;
  }

  inline bool IsCompleted() const {
    // TODO
    return false;
  }

  ts::DuckContext context_;
  ts::SectionDemux demux_;
  ts::Time start_time_;  // UTC
  std::unordered_set<std::string> collected_;
  size_t num_logos_ = 0;
};

}  // namespace
